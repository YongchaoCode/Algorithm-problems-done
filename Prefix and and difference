//前缀和 and 差分：
//前缀和：
/*
        arr[n](下标从1开始):1 4 3 9 4
  前缀和sum[n]： 1 5 8 17 21
   问题：询问q次区间[l,r]内的区间和：
    直接遍历数组并相加，时间复杂度：O(nq)
     利用前缀和公式：sum[l,r]==sum[r]-sum[l-1] (eg:sum[3,5](3+9+4)==sum[5](21)-sum[2](5))
 */

//差分：
/*
                    arr[n]:1 3 7 5 2
   差分(b[n]==a[n]-a[n-1]): 1 2 4 -2 -3
   差分的前缀和sum_b：(代表了原序列): 1 3 7 5  2
    问题：m次操作对arr区间[l,r]的每一个序列加c
       只需要两个操作：b[l]+c,b[r+1]-v,然后再进行前缀和
        eg: b[n]:0 0 0 0 0
         在对b[n]的第二个元素+c：0 c 0 0 0
          然后前缀和后：在第二个元素及后面的所有元素都会+c
           如果只是想在区间[2,4]的元素+c,就 在差分第4+1个的元素-c,
            因为在第5个元素及后面的元素会因为差分第一次+c和第二次减c之后抵消
 结论公式：得到操作[l,r]+c后的数组 <==> d[l]+v,d[r+1]-v ，然后对差分前缀和
  时间复杂度：直接枚举访问:O(m*n)  差分：O(m+n)线性复杂度
 */

//对数组arr区间的[l,r]的元素+c，并输出
#include<bits/stdc++.h>

using namespace std;
int a[10];
int b[11];//细节：为什么差分b[]的长度比a[]要大一个：防止越界
void add(int l, int r, int c) {
    b[l] += c;
    b[r + 1] -= c;//这就是细节处，防止差分数组越界
}

int main() {
    int n, l, r, c;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    cin >> l >> r >> c;//（下标从0开始）

    /*！！！ 最开始定义差分b[]，不需要算出初始的差分，
      eg： 对[0,2]的数组+1
            最开始差分：0 0 0 0 0
            差分操作后：1 0 0 -1 0
       然后对差分前缀和：1 1 1 0 0
        再然后对原数组和差分前缀和数组各自的元素相加: for:a[i]+b[i]
          最后输出a[]即是最终答案
    */

    add(l, r, c);
    for (int i = 1; i < n; i++) {//差分前缀和
        b[i] += b[i - 1];
    }
    for (int i = 0; i < n; i++) {
        a[i] += b[i];
    }

    for (int i = 0; i < n; i++) {
        cout << a[i] << " ";
    }
    return 0;
}
